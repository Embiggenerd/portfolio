<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="article-style.css">
  <style>
    h3 {
      font-size: 24px;
      margin: 12px 0;
    }
  </style>
  <title>How node actually works, part 3</title>
</head>

<body>

  <div class="article-container">
    <navbar-component></navbar-component>

    <div class="article-wrapper">

      <h1>How node actually works, part 3: Promises and async/await</h1>
      <p>
       It's been a long journey boys and girls, but buckle up, the ride is about to get rougher. We are getting into cartoonish levels
       of large wooden platform energy, and even though we can only go down from here, we are going to keep challenging ourselves. We've
       gone over how the operating system constructs an event stream for our event loop to demultiplex in 
       <a href="https://medium.com/@igor.atakhanov/how-node-actually-works-part-1-the-operating-system-497fd0de8167">
        Part One
      </a>,
        then we went over how Turbofan and Igninition both compile and interpret your Javascript, and the hows and whys of the event loop
        in <a href="node-part-two.html">Part Two</a>. But we still need go over why promises exist and how they are implemented.
      </p>

      <h2>
        Why Promises Exist
      </h2>

      <p>
        First, there was synchronous code. Everything was fine, until we had to make a network call, and then everything went south, because 
        networks are slow and unpredictable. You don't know if you're gonna get an error, and you don't know how long the call will take.
        After we figured out single threaded I/O, we still had the problem of how to compose our code. Let's say that we make a get request,
        and store the result in a variable called 'response.' Remember, we used a macrotask to do this. All of the synchronous code around it
        will be long executed before we call comes back. How do we process the response, such as put in a state, or write to a database? 
        Callbacks.
      </p>

      <pre>
        HTTP.get("url", function(error, response){
          if (error) {
            console.log(error)
          } else {
            doSomething(function(error, secondResponse){
              if (error) {
                console.log(error)
              } else {
                doSomethingAgain(function(error, thirdResponse){
                  if (error) {
                    console.log(error)
                  } else {
                    doSomethingAThirdTime(function(error, forthResponse){
                      // You get the point
                    })
                  }
                })
              }
            })
          }
        })
      </pre>

      <p>
        What's happening is our response from each function is being passed as a the argument to th enext function. Remember that a macrotask
        can place another task in the macrotask queue, or it can place a task in the microtask queue, which itself can use either queue. The 
        that we get to delay 'synchronous' code that deals with asynchronous code so that it doesn't execute on the stack before our async 
        function comes back with a result, is to place that synchronous code onto the microtask queue using proces.nextTick(). That's what 
        each callback is - it's a callback that's delayed until the data comes through, and as you can tell, there is no limit to how many
        callbacks are used in a row, which is bad, because it looks like shit. This is what bootcamp graduates call 'callback hell' in the 
        same way that millenials talk about Jimi Hendrix.
      </p>

      <h2>
        Promises
      </h2>

      <pre>
        HTTP.get('url')
          .then(response => {
            return doSomething(response)
          })
          .then(secondResponse => {
            return doSomethingAgain(secondResponse)
          })
          .then(thirdResponse => {
            return doSomethingAThirdTime(thirdResponse)
          })
          .cach(error => {
            console.log(error)
          })
      </pre>

      <p>
        Better, isn't it? Internally, our HTTP.get returns a promise that resolves to the value that comes back on the network. A promise has 
        a method called 'then', which is passed the result of the network call as an argument, and invokes it callback on that value. It uses
        something like process.nextTick, similarly to our callback hell example, but looks much cleaner. Notice, earlier, each new callback 
        had control over what it did with error and response. Our promise, on the other hand, has control over what's going on the whole time,
        and so can decide to handle the error in a .catch. The .then is also chainable, and will pass on its return value as the argument to
        the next then. 
      </p>

      <p>
        We said that our HTTP.get method 'returns a promise'. What does this mean? Let's say ordinarily, it uses XMLHttpRequest, which uses
        callback pattern. How would we get it to use promises? 
      </p>

      <pre>
        HTTP = {}
        HTTP.get = function(url){
          return new Promise(                              // A
            function(resolve, reject) {                    // B
              const req = new XMLHttpRequest('GET', url,   
                (error, response) => {                     // C
                  if (error) {
                    reject(error)
                  } else {
                    resolve(response)                      // D
                  }
                })
            })
        } 
      </pre>

      <p>
        On line A we are turning a promise, not any kind of 'value'. It will contain the value, but remember to use al the foodies of a 
        promise, we gotta return one. B is very important, because it shows that we are passing a function to promise's constructor. This 
        function takes two arguments, the first one is resolve, the second is reject. At C, we see that XMLHttpRequest's callback pattern
        also takes two arugemtns, error and response. However, as wee see in the if/else block, resolve and reject are functions, where as 
        error and response are not.
      </p>

      <pre>
        HTTP.get('some_url')
          .then(res => handleRes(res))
          .cach(err => handleError(err))
      </pre>

      <p>
        Above is the whole reason we made promises, and you can see, it's quite convenient. The callbacks passed to .then and .catch are 
        are synchronous code, yet delayed until the data comes back over the network, or there is an error. Unlike callbacks, we get a nice 
        way to compose our handlers, and don't have to worry about hard to read code. Easy, huh? Well, by now, we know easy to use means 
        hard to implement. If we didn't code a promise from scratch, this would be a different kind of blog series, wouldn't it. 
      </p>

      <h2>
        Implementing a promise
      </h2>

      <h3>
        Executor
      </h3>
      <pre>
  class MyPromise{
    constructor(executor) {
      executor()
    }
  }
      </pre>

      <p>
        The function that we passed to the constructor is called the executor, and it must be invoked immediately.  
      </p>

      <pre>
  let foo = ''
  new MyPromise(()=>{
    foo = "bar"
  })
  console.log(foo)
  
  // Output
  // bar
      </pre>

      <h3>
        Resolution handler
      </h3>

      <p>
        At some point' our promise must be 'resolved'. This means that we did not get an error, whatever async thing got done, such as an 
        I/O event or a setTimeout event, and now we want the callback we passe to .then to get called on the result. This callback is 
        called resolution handler, because it is invoked on resolution, and it 'handles' the result.
      </p>

      <pre>
  class MyPromise{
    constructor(executor) {
      this._resolutionHandlerQueue = []              // A
      executor(this._resolve.bind(this))             // B
    }

    _resolve(value {                                 // C
      while(this._resolutionQueue.length > 0) {      // D
        const handler = this._resolutionQueue.shift()
        handler(value)                               // E
      }
    })

    then(resolutionHandler) {
      this._resolutionQueue.push(resolutionHandler)  // F
    }
  }
      </pre>

      <p>
        So, things are getting hairy, but relax, we will go slowly. The reason we have a resolution handler queue at A is that the 
        resolution handler is given to us synchronously, and we need to hold onto it for when we resolve. It's a queue because we 
        know we may need to call then many times, which means there will be many resolution handlers. Line B should be very confusing.
        We are calling executor on _resolve, which is bound to our promise since. Why is it bound, and when it it called? Remeber back
        when we used HTTP.get? Look carefully where resolve is called on line D. That's right, that function is called in the definition
        of the executor, like this.
      </p>

      <pre>
  let foo = "bar"

  const promise = new MyPromise(function(resolve) { // G
    setTimeout(function(){
      resolve(foo)                                  // H
    }, 1000)
  })

  promise.then(function(string) {                   // I
    console.log(string === "bar")                   // J
  })

  // Output
  // true
      </pre>

      <p>
        We define our executor starting on G, and it contains a setTimout that invokes resolve on foo. This resolve is a reference
        to _resolve in our promise. It is being called on a string. Let's go back to D, and see our definition of _resolve takes a 
        handler off our resolution handler queue, and calls it on the value at E, which is our string at I and J. Trippy, right? If 
        you don't get it yet, that means you're normal, keep going over it. When you get it, move onto the next section where we 
        figure out how to chain resolution handlers. 
      </p>

      <h3>
        Resolution handlers can be chained
      </h3>

      <p>
        One of the most important aspects of promises is being able to chain promises together. If returning a promise from a function 
        allows us to call .then, then returning a promise from .then will allow us to chain .thens. 
      </p>

      <pre>
  class MyPromise{
    constructor(executor) {
      this._resolutionHandlerQueue = []              
      executor(this._resolve.bind(this))             
    }

    _resolve(value {                                 
      while(this._resolutionQueue.length > 0) {      
        const resolution = this._resolutionQueue.shift()
        const returnValue = resolution.handler(value)       // D
        
        if (returnValue instanceof MyPromise) {             // E
          returnValue.then(function(v) {                    // F
            resolution.promise._resolve(v)                  // G
          })
        }
      }
    })

    then(resolutionHandler) {
      const newPromise = new MyPromise(function(){})        // A
      this._resolutionQueue.push({                          
        handler: resolutionHandler,                    
        promise: newPromise                                 // B
      })  
      return newPromise                                     // C
    }
  }
      </pre>

      <p>
        The first thing we have to worry about is how to handle the returned promise at C, or more succinctly, where do we resolve 
        that returned promise. Where ever we have that logic, we have to be able to reference that returned promise, and so we store 
        that reference at B after creating at A. Notice, our resolution handler queue now stores objects with the resolution handler 
        passed to .then, and our returned promise. At D, we change our returnValue accordingly, then ask if that return value is 
        itself a promise. That's because we are tesing for the case when oure resolution handler returns a promise:
      </p>

      <pre>
  let foo = "bar"
  const promise = new MyPromise(function(resolve) {
    setTimeout(function(){
      resolve()
    }, 1000)
  })

  promise.then(function(){

    return new MyPromise(function(resolve){               // H
      setTimeout(function(){
        resolve(foo)
      }, 1000)
    })

  }).then(function(string){
    console.log(string === "bar")
  })

  // Output after 2 seconds
  // true
      </pre>

    </div>
  </div>

  <script src="components/navbar-component.js"></script>

</body>

</html>