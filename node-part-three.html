<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="article-style.css">
  <title>How node actually works, part 3</title>
</head>

<body>

  <div class="article-container">
    <navbar-component></navbar-component>

    <div class="article-wrapper">

      <h1>How node actually works, part 3: Promises and async/await</h1>
      <p>
       It's been a long journey boys and girls, but buckle up, the ride is about to get rougher. We are getting into cartoonish levels
       of large wooden platform energy, and even though we can only go down from here, we are going to keep challenging ourselves. We've
       gone over how the operating system constructs an event stream for our event loop to demultiplex in 
       <a href="https://medium.com/@igor.atakhanov/how-node-actually-works-part-1-the-operating-system-497fd0de8167">
        Part One
      </a>,
        then we went over how Turbofan and Igninition both compile and interpret your Javascript, and the hows and whys of the event loop
        in <a href="node-part-two.html">Part Two</a>. But we still need go over why promises exist and how they are implemented.
      </p>

      <h2>
        Why Promises Exist
      </h2>

      <p>
        First, there was synchronous code. Everything was fine, until we had to make a network call, and then everything went south, because 
        networks are slow and unpredictable. You don't know if you're gonna get an error, and you don't know how long the call will take.
        After we figured out single threaded I/O, we still had the problem of how to compose our code. Let's say that we make a get request,
        and store the result in a variable called 'response.' Remember, we used a macrotask to do this. All of the synchronous code around it
        will be long executed before we call comes back. How do we process the response, such as put in a state, or write to a database? 
        Callbacks.
      </p>

      <pre>
        HTTP.get("url", function(error, response){
          if (error) {
            console.log(error)
          } else {
            doSomething(function(error, secondResponse){
              if (error) {
                console.log(error)
              } else {
                doSomethingAgain(function(error, thirdResponse){
                  if (error) {
                    console.log(error)
                  } else {
                    doSomethingAThirdTime(function(error, forthResponse){
                      // You get the point
                    })
                  }
                })
              }
            })
          }
        })
      </pre>

      <p>
        What's happening is our response from each function is being passed as a the argument to th enext function. Remember that a macrotask
        can place another task in the macrotask queue, or it can place a task in the microtask queue, which itself can use either queue. The 
        that we get to delay 'synchronous' code that deals with asynchronous code so that it doesn't execute on the stack before our async 
        function comes back with a result, is to place that synchronous code onto the microtask queue using proces.nextTick(). That's what 
        each callback is - it's a callback that's delayed until the data comes through, and as you can tell, there is no limit to how many
        callbacks are used in a row, which is bad, because it looks like shit. This is what bootcamp graduates call 'callback hell' in the 
        same way that millenials talk about Jimi Hendrix.
      </p>

      <h2>
        Promises
      </h2>

      <pre>
        HTTP.get('url')
          .then(response => {
            return doSomething(response)
          })
          .then(secondResponse => {
            return doSomethingAgain(secondResponse)
          })
          .then(thirdResponse => {
            return doSomethingAThirdTime(thirdResponse)
          })
          .cach(error => {
            console.log(error)
          })
      </pre>

      <p>
        Better, isn't it? Internally, our HTTP.get returns a promise that resolves to the value that comes back on the network. A promise has 
        a method called 'then', which is passed the result of the network call as an argument, and invokes it callback on that value. It uses
        something like process.nextTick, similarly to our callback hell example, but looks much cleaner. Notice, earlier, each new callback 
        had control over what it did with error and response. Our promise, on the other hand, has control over what's going on the whole time,
        and so can decide to handle the error in a .catch. The .then is also chainable, and will pass on its return value as the argument to
        the next then. 
      </p>

      <p>
        We said that our HTTP.get method 'returns a promise'. What does this mean? Let's say ordinarily, it uses XMLHttpRequest, which uses
        callback pattern. How would we get it to use promises? 
      </p>

      <pre>
        HTTP = {}
        HTTP.get = function(url){
          return new Promise(                              // A
            function(resolve, reject) {                    // B
              const req = new XMLHttpRequest('GET', url,   
                (error, response) => {                     // C
                  if (error) {
                    reject(error)
                  } else {
                    resolve(response)                      // D
                  }
                })
            })
        } 
      </pre>

      <p>
        On line A we are turning a promise, not any kind of 'value'. It will contain the value, but remember to use al the foodies of a 
        promise, we gotta return one. B is very important, because it shows that we are passing a function to promise's constructor. This 
        function takes two arguments, the first one is resolve, the second is reject. At C, we see that XMLHttpRequest's callback pattern
        also takes two arugemtns, error and response. However, as wee see in the if/else block, resolve and reject are functions, where as 
        error and response are not.
      </p>

      <pre>
        HTTP.get('some_url')
          .then(res => handleRes(res))
          .cach(err => handleError(err))
      </pre>

      <p>
        Above is the whole reason we made promises, and you can see, it's quite convenient. The callbacks passed to .then and .catch are 
        are synchronous code, yet delayed until the data comes back over the network, or there is an error. Unlike callbacks, we get a nice 
        way to compose our handlers, and don't have to worry about hard to read code.
      </p>

    </div>

  </div>

  <script src="components/navbar-component.js"></script>

</body>

</html>