<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <link rel="stylesheet" href="article-style.css">
  <title>How node actually works, part 3</title>
</head>

<body>

  <div class="article-container">
    <navbar-component></navbar-component>

    <div class="article-wrapper">

      <h1>How node actually works, part 3: Promises and async/await</h1>
      <p>
       It's been a long journey boys and girls, but buckle up, the ride is about to get rougher. We are getting into cartoonish levels
       of large wooden platform energy, and even though we can only go down from here, we are going to keep challenging ourselves. We've
       gone over how the operating system constructs an event stream for our event loop to demultiplex in 
       <a href="https://medium.com/@igor.atakhanov/how-node-actually-works-part-1-the-operating-system-497fd0de8167">
        Part One
      </a>,
        then we went over how Turbofan and Igninition both compile and interpret your Javascript, and the hows and whys of the event loop
        in <a href="node-part-two.html">Part Two</a>. But we still need go over why promises exist and how they are implemented.
      </p>

      <h2>
        Why Promises Exist
      </h2>

      <p>
        First, there was synchronous code. Everything was fine, until we had to make a network call, and then everything went south, because 
        networks are slow and unpredictable. You don't know if you're gonna get an error, and you don't know how long the call will take.
        After we figured out single threaded I/O, we still had the problem of how to compose our code. Let's say that we make a get request,
        and store the result in a variable called 'response.' Remember, we used a macrotask to do this. All of the synchronous code around it
        will be long executed before we call comes back. How do we process the response, such as put in a state, or write to a database? 
        Callbacks.
      </p>

      <pre>
        HTTP.get("url", function(response){
          doSomething(response, function(secondResponse){
            doSomethingAgain(secondResponse, function(){
              doSomethingAThirdTime(thirdResponse, function(){
                // You get the point
              })
            })
          })
        })
      </pre>

      <p>
        What's happening is our response from each function is being passed as a the argument to th enext function. Remember that a macrotask
        can place another task in the macrotask queue, or it can place a task in the microtask queue, which itself can use either queue. The 
        that we get to delay 'synchronous' code that deals with asynchronous code so that it doesn't execute on the stack before our async 
        function comes back with a result, is to place that synchronous code onto the microtask queue using proces.nextTick(). That's what 
        each callback is - it's a callback that's delayed until the data comes through, and as you can tell, there is no limit to how many
        callbacks are used in a row, which is bad, because it looks like shit. This is what bootcamp graduates call 'callback hell' in the 
        same way that millenials talk about Led Zeppelin.
      </p>

      <h2>
        Promises
      </h2>

    

    </div>

  </div>

  <script src="components/navbar-component.js"></script>

</body>

</html>